# Checker Pattern

## Intent
The Checker Pattern provides an independent verification mechanism that evaluates, validates, or offers an alternative approach to a solution already generated by another component. It serves as a trust-building layer that increases confidence in the system's output through cross-validation or alternative solution generation.

## Also Known As
- Validator Pattern
- Verifier Pattern
- Cross-Checker
- Alternative Solver
- Solution Validator

## Motivation
In complex problem-solving systems, especially those involving AI or computational processes, having a single approach to solving a problem may lead to errors, biases, or incomplete solutions. The Checker Pattern addresses this concern by:

1. Providing an independent verification mechanism
2. Generating alternative solutions using different methodologies
3. Increasing confidence in the correctness of the primary solution
4. Offering a different perspective that may be more intuitive or elegant

Consider a mathematical problem-solving system. After the primary solver has generated a solution, users may want verification that the solution is correct or may benefit from seeing an alternative approach. By employing a separate, independent model with different training or underlying architecture, the system can provide this verification or alternative perspective.

The Checker Pattern implements this verification layer, ensuring that solutions are validated or complemented by an independent process.

## Applicability
Use the Checker Pattern when:
- Solution correctness is critical and verification is needed
- Multiple valid approaches to solving a problem exist
- You want to provide users with alternative solution methods for educational purposes
- Different models or algorithms may have complementary strengths and weaknesses
- You need to build trust in AI-generated solutions
- The domain benefits from diverse problem-solving approaches

## Structure
![Checker Pattern Structure](https://www.example.com/checker_pattern.png)

## Participants
- **Client**: The component that initiates the checking process
- **CheckerAgent**: Implements the verification or alternative solution generation logic
- **Model/LLM**: The underlying independent model that performs the verification or alternative solution generation
- **Workflow**: Coordinates the overall process and combines primary and checker outputs

## Collaborations
1. The **Client** (or upstream component like a Workflow) provides a problem and possibly a primary solution to the **CheckerAgent**
2. The **CheckerAgent** constructs a prompt that incorporates the problem
3. The **CheckerAgent** passes the prompt to its independent **Model/LLM**
4. The **Model/LLM** processes the prompt and returns an alternative solution
5. The **CheckerAgent** provides the alternative solution back to the **Workflow**
6. The **Workflow** presents both the primary and alternative solutions to the user

## Implementation
The Checker Pattern is implemented in the provided `AceMathAgent` class. The key elements include:

### The Prompt Template
The prompt is relatively simple, as it primarily passes the problem to the alternative model:

```python
formatted_prompt = f"[INST] {problem} [/INST]"
```

This prompt includes:
1. A simple instruction wrapper format ([INST] ... [/INST])
2. The problem to solve
3. No reference to the primary solution, ensuring independence

### Required Properties for Implementation
To implement the Checker Pattern effectively, the following properties are necessary:

1. **Model Independence**: The checker should use a different model or algorithm than the primary solver to provide genuine verification.

2. **Specialized Model Selection**: The implementation should select models that are well-suited for the specific domain (e.g., AceMath for mathematics).

3. **Dependency Management**: The implementation should handle optional dependencies gracefully, as seen in the `_check_mlx_imports()` method.

4. **Fallback Mechanisms**: When the specialized checker is unavailable, the system should have fallback options (as seen in the workflow).

5. **Performance Considerations**: Since checkers add computational overhead, implementations should use progress indicators and efficient processing.

6. **Output Consistency**: Even though the checker uses a different model, its output format should be compatible with the primary solution for easy comparison.

7. **Resource Efficiency**: The implementation should load specialized models only when needed and handle resources efficiently.

## Sample Code
```python
def process(self, problem: str) -> str:
    """
    Solve a math problem using the MLX-based AceMath model.
    
    Args:
        problem: The formatted math problem to solve
        
    Returns:
        The solution to the math problem
    """
    console.print("[bold]Step 3:[/bold] Getting alternative solution with AceMath model...")
    
    if not self.math_model or not self.tokenizer:
        return "AceMath model is not loaded. Cannot provide alternative solution."
    
    try:
        # Import only when needed
        from mlx_lm.utils import generate
        from mlx_lm.sample_utils import make_sampler
        
        # Format prompt for instruction model - using raw string to avoid issues with brackets
        formatted_prompt = f"[INST] {problem} [/INST]"
        
        with Progress() as progress:
            task = progress.add_task("[cyan]Processing with AceMath...", total=None)
            
            # Create a sampler with the specified temperature
            sampler = make_sampler(temp=0.7)
            
            # Generate response using mlx_lm
            response = generate(
                self.math_model,
                self.tokenizer,
                prompt=formatted_prompt,
                max_tokens=200,
                sampler=sampler
            )
            
            progress.update(task, completed=100)
        
        console.print("[green]âœ“ Alternative solution generated with AceMath[/green]")
        return response
        
    except Exception as e:
        console.print(f"[bold red]Error solving with AceMath: {str(e)}[/bold red]")
        return f"Error: {str(e)}"
```

## Known Uses
- Verification of computational results in scientific computing
- Alternative solution generation in educational platforms
- Cross-checking in financial calculation systems
- Multi-model consensus approaches in critical AI systems
- Diverse problem-solving approaches in tutoring systems
- Verification steps in formal proof systems

## Related Patterns
- **Strategy Pattern**: Different checker implementations can represent different verification strategies
- **Decorator Pattern**: Checkers can be added as decorations to enhance solution confidence
- **Observer Pattern**: Checkers can observe the primary solution process without interfering
- **Chain of Responsibility**: Multiple checkers can be chained to provide different verification perspectives
- **Adapter Pattern**: Adapts outputs from different models into a consistent format for comparison

## Consequences
### Benefits
1. Increases confidence in solution correctness through independent verification
2. Provides educational value through multiple solution approaches
3. Offers a safety net against errors in the primary solution
4. Enhances user trust in the system's output
5. Can identify more elegant or efficient solutions than the primary approach

### Liabilities
1. Increases computational resource usage and processing time
2. May confuse users if alternative solutions differ significantly from primary solutions
3. Requires management of additional dependencies and models
4. Increases system complexity
5. May require specialized hardware (like Apple Silicon for MLX in this implementation)
